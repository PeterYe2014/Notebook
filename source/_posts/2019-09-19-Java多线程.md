---
 layout: post
 title:  "Java多线程" 
 date:  2019-09-22 00:20:04 +0800
--- 
# Java 多线程核心知识

标签（空格分隔）： Java

---

> 在操作系统中，我们学到线程是最基本的调度单位，而进程是最基本的资源分配单位。通过多线程在单CPU的环境下面，我们能够给每个线程分配一个小的时间片，时间片完成后切换到下一线程，从而实现**并发**,程序对于用户来说感觉像是在同时运行一样。

## 使用多线程的方法

### 继承 Thread

通过继承Thread类，并且覆盖他的run方法，我们就能够定义一个自己的线程；同时线程的运行顺序是不确定的，但是我们可以使用SetPriority()方法调整他们的优先级，通过内部类定义Thread可以更好地访问业务类的变量，优化代码结构。
```
class MyThread extend Thread{
  public void run(){
     System.out.print("hello thread");
  }
};
```

### 实现Runnable
Runnable里面具有接口run，我们可以实现run接口，然后通过Runnable来构造线程。
```
class MyTask implements Runnale{
    
    public void run(){
        
        // do something 
    }
}
Thread myThread = new Thread(new MyTask());
myThread.start();
```
其实Runnable接口就是为了一个类添加了一个run方法而已。采用Runnable，可以让所有的中间变量属于一个类，从而更好的去访问变量。同时当多个线程运行的时候，线程调度器会自己结合目前的情况，调度不同的线程来运行，如果是单处理器计算机，调度器会给每个任务一定的分片时间来运行，并发处理；如果是多处理器的计算机，调度器会把任务分配到处理器上并行处理。并且不同的JDK版本会有不同的调度算法，所有往往多线程的程序运行结果是不可预测的。

### 使用Excutors

在Java SE 5中开始提供了一种间接方法来使用多线程，这种方法不用去直接创建线程对象，而是通过线程池来管理线程的生命周期，更节省线程的创建资源，以及更好地管理使用线程。
```
ExcutorService exec = Executors.newCachedTreadPool();
exec.submit(new MyTask());
exec.shudown();
```

通过Executors静态方法，我们创建了一个ExcutorService，通过submit方法将实现Runnable接口的任务提交到线程池里面，就会自动创建线程运行被提交的任务，shutdown方法是关闭了任务的提交，调用后就不能再提交任务运行了。

线程池除了CachedThreadPool之外，常用的还有FixedThreadPool和SingleThreadPool,都可以通过静态方法Executors.newXXX来创建。CachedThreadPool在运行任务的情况下，会创建尽可能多的线程，直到旧的线程被回收。而FixedThreadPool，创建时要接收一个数量参数，也就是创建的线程数量是有限的，这样可以减少线程创建的资源消耗，并且里面的线程会尽可能地复用，从而有较快的相应速度，在事件驱动的系统里面比较适用。SingleThreadPool是FixedThreadPool参数为1的特殊情况，该线程池的一个最大的特点就是，submit多个任务到SingleThreadPool的时候，任务会进行排队，一个任务执行完后才会执行下一个任务，也就是说SingleThreadPool能够达到同步的作用（虽然不是最好的同步方法）


### 有返回值的多线程任务

我们通过Runnable接口定义的任务可以在多线程里面运行，然而有时候需要任务有返回值得时候，Runnable的run接口却不能满足要求，所以Java SE 5新增了一个Callable接口，该接口是一个泛型接口，泛型参数对于接口方法call的返回值，同时Callable接口不能像Runnable里面直接传入Thread必须要通过ExecutorService的sumbit来提交运行。并且submit还会返回一个泛型Future对象，用来包含call方法的返回值。

```
class CallableTask implements Callable<String>{
    private int taskId;
    
    public CallableTask(int id){
      this.taskId = id;
    }
    public String call(){
      return "hello callable task " + id;
    }
}

public static void main(String[] args){
    ExecutorService exec = Executors.newCachedThreadPool();
    Future<String> fs = exec.sumbit(new CallableTask(1));
    exec.shutdown();
    System.out.println(fs.get());
}
```

## 一些特殊的线程方法

## Sleep方法

在线程的运行中，我们调用Thread.sleep()方法可以让当前线程阻塞一定的时间，从而让线程调度器，调度其它线程执行，Java SE5开始已经支持了通过TimeUnit新接口来进行线程休眠。
```
Thread.sleep(100) // 100ms
TimeUnit.MILLISECONDS.sleep(100) // Java SE5的新API
```

##  使用守护线程
程序中，一旦所有的非守护线程完成，程序也会突然终止。可以通过SetDaemon来设置线程为守护线程。如果是一个Daemon 线程，那么它创建的任何线程也会自动具备Daemon 属性。这里要注意一个问题，守护线程里面的finally语句不一定会被执行到（由于它的突然中断原因）
```
myThread.setDaemon(true);// 线程启动之前设置
```
## yield方法

如果当前任务完成的时候，可以调用Thread.yield()方法，该方法提醒调度器当前线程有放弃运行的想法，可以调度其它***同优先级*线程运行，但是调度器也可以忽略该提醒

## 设置线程优先级

线程的优先级表明了一个线程的重要性，线程调度器在调度线程运行的时候，会偏向调度优先级高的线程。默认情况下优先级的设置不是一个好的选择。
```
// 虽然JDK支持10级，但可以设置只有 MAX_PRIORITY, NORM_PRIORITY和MIN_PRIORITY
myThread.setPriority(Thread.MAX_PRIORITY); // 设置为最大的优先级
```

## Join方法

当某个线程A，调用了另一个线程B的join方法，那么A线程就会被挂起，直到B线程执行完成后（B.isAlive()==false）才继续运行。这里实现的功能相当于将A和B线程的功能连接起来了，实现了BA功能（先运行B再运行A)，故该方法由此得名。同时join方法可以传入一个timeout参数，超时后join方法能够直接返回而不至于阻塞很久，并且join方法能够被interrupt方法中断，所以调用的时候需要使用try...catch...方法


## 异常捕捉

在多线程环境下，异常一般情况下都要在run函数的内部进行捕捉，如果没有在run函数里面捕捉相应的异常，那么run函数的异常在外部通过try...catch方法是捕捉不到的，这里就出现了未捕捉的异常，Java线程也提供了方法来解决这个处理这个未捕捉的异常，也就是*UncaughtExceptionHandler*接口，实现该接口定义**uncaughtException(Thread t, Throwable e)**方法，从而处理线程中的未捕捉异常。这里需要事先调用**Thread.setUncaughtExceptionHandler()**方法设置hanlder，从而能够处理未捕捉的异常。
也可以为所有的线程设置默认的未捕捉异常处理器

```
Thread.setDefaultUncaughtExceptionHandler(
new MyUncaughtExceptionHandler());
```

## 资源的共享

### 使用synchronized关键字来同步
在多线程的环境下，可能有多个程序访问有限的资源，导致资源的访问冲突，为了解决这种冲突，我们需要给资源加上锁，让资源同一时刻只能被一个线程访问。（互斥机制）

java 中通过synchronized关键字来将对象方法标识为同步的，之后在任何时刻，只有一个线程可以调用特定对象的一个synchronized方法。因为每个对象都有一把锁（监视器），他是对象的一部分，调用任何synchronized方法后对象就会被锁定，不能再调用其它的synchronized方法。也就是特定对象的所有synchronized方法共享一把锁。

有些时候由于方法需要很长时间才能够结束，直接将方法标记为synchronized，会导致其它的synchronized长时间不能被调用，这样java提供了另一种使用synchronized的方法，synchronized区块，可以标记特定区域为“同步块”，
```
synchronized(object){

}

```
在进入同步块之前，必须获取object的锁，如果已经有其它线程取得了这把锁，块就不能进入，必须等锁被释放。

>同步的效率：使用synchronized会产生额外的代价，如果知道冲突不会发生，则可以撤销synchronized关键字。

### 使用lock方法来同步

ReentrantLock()

try finally

unlock在finally里面

return 在catch里面

更好的在异常的时候维持锁的状态正确
可以tryLock，指定时间和不指定时间，避免多余等待浪费时间

### volatile 关键字

多处理机里面的，每次写操作的时候可能在本地的处理器缓存里面，读却读不到改变的结果，（sychronized关键字会自动解决这个问题）

如果没有使用同步机制，那么变量的可见性就得不到保证，这里就需要volatile关键字来保证变量的可见性，该关键字保证每次变量被写后，读出的值都是最新的值。
volatile 不起作用的情况，变量的值依赖变量之前的值，i++,
变量的值被其它变量限制（？详情例子）


## 线程的中断